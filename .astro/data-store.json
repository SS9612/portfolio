[["Map",1,2,7,8],"meta::meta",["Map",3,4,5,6],"astro-version","5.14.6","astro-config-digest","{\"root\":{},\"srcDir\":{},\"publicDir\":{},\"outDir\":{},\"cacheDir\":{},\"site\":\"https://portfolio-22420.web.app/\",\"compressHTML\":true,\"base\":\"/\",\"trailingSlash\":\"ignore\",\"output\":\"static\",\"scopedStyleStrategy\":\"attribute\",\"build\":{\"format\":\"directory\",\"client\":{},\"server\":{},\"assets\":\"_astro\",\"serverEntry\":\"entry.mjs\",\"redirects\":true,\"inlineStylesheets\":\"auto\",\"concurrency\":1},\"server\":{\"open\":false,\"host\":false,\"port\":4321,\"streaming\":true,\"allowedHosts\":[]},\"redirects\":{},\"image\":{\"endpoint\":{\"route\":\"/_image\"},\"service\":{\"entrypoint\":\"astro/assets/services/sharp\",\"config\":{}},\"domains\":[],\"remotePatterns\":[],\"responsiveStyles\":false},\"devToolbar\":{\"enabled\":true},\"markdown\":{\"syntaxHighlight\":{\"type\":\"shiki\",\"excludeLangs\":[\"math\"]},\"shikiConfig\":{\"langs\":[],\"langAlias\":{},\"theme\":\"github-dark\",\"themes\":{},\"wrap\":false,\"transformers\":[]},\"remarkPlugins\":[],\"rehypePlugins\":[],\"remarkRehype\":{},\"gfm\":true,\"smartypants\":true},\"security\":{\"checkOrigin\":true,\"allowedDomains\":[]},\"env\":{\"schema\":{},\"validateSecrets\":false},\"experimental\":{\"clientPrerender\":false,\"contentIntellisense\":false,\"headingIdCompat\":false,\"preserveScriptOrder\":false,\"liveContentCollections\":false,\"csp\":false,\"staticImportMetaEnv\":false,\"chromeDevtoolsWorkspace\":false,\"failOnPrerenderConflict\":false},\"legacy\":{\"collections\":false}}","projects",["Map",9,10,18,19,25,26,32,33],"tasktide",{"id":9,"data":11,"body":13,"filePath":14,"digest":15,"legacyId":16,"deferredRender":17},{"title":12},"TaskTide Case Study","## Overview\r\nTaskTide is a kanban-style task manager focused on fast interactions and collaboration.\r\nThe goal was to ship a delightful, responsive UI with low operational overhead.\r\n\r\n## Highlights\r\n- Optimistic UI updates with server reconciliation\r\n- Realtime presence and board updates\r\n- Zero-config deployments and preview environments\r\n\r\n## Architecture\r\nFrontend uses React with server-rendered routes. Data layer abstracts network retries and\r\nserialization. Below is a simplified example of an optimistic update pattern:\r\n\r\n```ts\r\nasync function addCard(columnId: string, title: string) {\r\n  const tempId = `temp-${Date.now()}`;\r\n  boardState.addLocal({ id: tempId, columnId, title });\r\n  try {\r\n    const created = await api.createCard({ columnId, title });\r\n    boardState.replace(tempId, created);\r\n  } catch (err) {\r\n    boardState.remove(tempId);\r\n    throw err;\r\n  }\r\n}\r\n```\r\n\r\n> Notes: Optimistic UIs dramatically improve perceived performance but require careful\r\n> error recovery and idempotent server handlers.","src/content/projects/tasktide.mdx","a5fce36e413318a1","tasktide.mdx",true,"songshuttle",{"id":18,"data":20,"body":21,"filePath":22,"digest":23,"legacyId":24,"deferredRender":17},{},"# SongShuttle\r\n\r\n## Overview\r\n\r\nSongShuttle is a music transfer application that seamlessly moves playlists between YouTube and Spotify. Built with modern web technologies, it provides users with an intuitive interface to migrate their music collections across platforms while preserving metadata and maintaining high accuracy in song matching.\r\n\r\n## Key Features\r\n\r\n### OAuth Integration\r\n- Secure authentication with both YouTube and Spotify APIs\r\n- Token-based session management for seamless user experience\r\n- Automatic token refresh to maintain continuous access\r\n\r\n### Intelligent Song Matching\r\n- Advanced algorithm that matches songs across platforms using multiple criteria\r\n- Fuzzy matching for songs with slight title or artist variations\r\n- Manual override options for unmatched tracks\r\n\r\n### Real-time Transfer Progress\r\n- Live progress tracking with detailed status updates\r\n- Batch processing for large playlists without timeouts\r\n- Error handling and retry mechanisms for failed transfers\r\n\r\n### Playlist Metadata Preservation\r\n- Maintains original playlist structure and order\r\n- Preserves custom playlist names and descriptions\r\n- Handles various metadata fields including album art and release dates\r\n\r\nimport Mermaid from '@/components/Mermaid.astro';\r\n\r\n\u003CMermaid content={`flowchart TD\r\n    A[\"User Login\"] --> B[\"Select Source Platform\"]\r\n    B --> C[\"Choose Playlist\"]\r\n    C --> D[\"Select Target Platform\"]\r\n    D --> E[\"Configure Transfer Settings\"]\r\n    E --> F[\"Start Transfer Process\"]\r\n    F --> G[\"Match Songs Algorithm\"]\r\n    G --> H{\"All Songs Matched?\"}\r\n    H -->|Yes| I[\"Create Target Playlist\"]\r\n    H -->|No| J[\"Show Manual Review\"]\r\n    J --> K[\"User Confirms Matches\"]\r\n    K --> I\r\n    I --> L[\"Transfer Complete\"]\r\n    L --> M[\"Show Results Summary\"]`} />\r\n\r\n## Technical Highlights\r\n\r\n### Backend Architecture\r\n- **C# ASP.NET Core** with clean architecture principles\r\n- RESTful API design with comprehensive error handling\r\n- Dependency injection and service layer pattern\r\n- Async/await patterns for optimal performance\r\n\r\n### Frontend Implementation\r\n- **React** with functional components and hooks\r\n- **Tailwind CSS** for responsive, mobile-first design\r\n- State management with React Context and useReducer\r\n- Custom hooks for API integration and data fetching\r\n\r\n### Cloud Infrastructure\r\n- **Google Cloud Run** for serverless, auto-scaling backend\r\n- **Cloud SQL (Postgres)** for persistent data storage\r\n- **Firebase Hosting** with global CDN for fast content delivery\r\n- Environment-based configuration for different deployment stages\r\n\r\n### API Integrations\r\n- **YouTube Data API v3** for playlist and video metadata\r\n- **Spotify Web API** for playlist management and track information\r\n- Rate limiting and quota management for both APIs\r\n- Comprehensive error handling and fallback strategies\r\n\r\n\u003CMermaid content={`sequenceDiagram\r\n    participant User\r\n    participant Frontend\r\n    participant Backend\r\n    participant YouTubeAPI\r\n    participant SpotifyAPI\r\n    participant Database\r\n\r\n    User->>Frontend: Login with YouTube\r\n    Frontend->>Backend: OAuth Request\r\n    Backend->>YouTubeAPI: Exchange Code for Token\r\n    YouTubeAPI-->>Backend: Access Token\r\n    Backend->>Database: Store User Session\r\n    Backend-->>Frontend: Authentication Success\r\n\r\n    User->>Frontend: Select Playlist to Transfer\r\n    Frontend->>Backend: Get Playlist Details\r\n    Backend->>YouTubeAPI: Fetch Playlist Data\r\n    YouTubeAPI-->>Backend: Playlist + Tracks\r\n    Backend->>Database: Cache Playlist Data\r\n    Backend-->>Frontend: Playlist Information\r\n\r\n    User->>Frontend: Start Transfer\r\n    Frontend->>Backend: Initiate Transfer\r\n    Backend->>SpotifyAPI: Create Target Playlist\r\n    Backend->>SpotifyAPI: Search & Match Tracks\r\n    SpotifyAPI-->>Backend: Matched Track IDs\r\n    Backend->>SpotifyAPI: Add Tracks to Playlist\r\n    Backend->>Database: Log Transfer History\r\n    Backend-->>Frontend: Transfer Complete\r\n    Frontend-->>User: Success Notification`} />\r\n\r\n## Code Highlights\r\n\r\n### Intelligent Song Matching Algorithm\r\n```csharp\r\n// Fuzzy matching with Levenshtein distance for cross-platform song search\r\npublic async Task\u003CSpotifyTrack> FindBestMatch(YouTubeVideo video)\r\n{\r\n    var searchQuery = $\"{video.Artist} {video.Title}\";\r\n    var candidates = await _spotifyClient.SearchTracks(searchQuery, limit: 10);\r\n    \r\n    return candidates\r\n        .Select(track => new {\r\n            Track = track,\r\n            Score = CalculateSimilarity(video, track)\r\n        })\r\n        .OrderByDescending(x => x.Score)\r\n        .FirstOrDefault()?.Track;\r\n}\r\n\r\nprivate double CalculateSimilarity(YouTubeVideo video, SpotifyTrack track)\r\n{\r\n    var titleSimilarity = LevenshteinDistance(video.Title, track.Name) / \r\n                         Math.Max(video.Title.Length, track.Name.Length);\r\n    var artistSimilarity = LevenshteinDistance(video.Artist, track.Artists.First().Name) / \r\n                          Math.Max(video.Artist.Length, track.Artists.First().Name.Length);\r\n    \r\n    return 1.0 - (titleSimilarity * 0.7 + artistSimilarity * 0.3);\r\n}\r\n```\r\n\r\n### Rate Limiting & Retry Logic\r\n```csharp\r\n// Exponential backoff for API rate limits with circuit breaker pattern\r\npublic async Task\u003CT> ExecuteWithRetry\u003CT>(Func\u003CTask\u003CT>> apiCall, int maxRetries = 3)\r\n{\r\n    for (int i = 0; i \u003C maxRetries; i++)\r\n    {\r\n        try \r\n        { \r\n            return await apiCall(); \r\n        }\r\n        catch (RateLimitException ex)\r\n        {\r\n            if (i == maxRetries - 1) throw;\r\n            \r\n            var delay = TimeSpan.FromSeconds(Math.Pow(2, i) + Random.Shared.Next(1, 3));\r\n            await Task.Delay(delay);\r\n        }\r\n    }\r\n    throw new MaxRetriesExceededException();\r\n}\r\n```\r\n\r\n### React Custom Hook for Transfer Progress\r\n```typescript\r\n// Custom hook for real-time transfer progress tracking with error handling\r\nfunction useTransferProgress(transferId: string) {\r\n  const [progress, setProgress] = useState\u003CTransferProgress>({ current: 0, total: 0 });\r\n  const [error, setError] = useState\u003Cstring | null>(null);\r\n  \r\n  useEffect(() => {\r\n    if (!transferId) return;\r\n    \r\n    const eventSource = new EventSource(`/api/transfers/${transferId}/progress`);\r\n    \r\n    eventSource.onmessage = (event) => {\r\n      try {\r\n        const data = JSON.parse(event.data);\r\n        setProgress(data);\r\n        setError(null);\r\n      } catch (err) {\r\n        setError('Failed to parse progress data');\r\n      }\r\n    };\r\n    \r\n    eventSource.onerror = () => {\r\n      setError('Connection lost. Retrying...');\r\n      eventSource.close();\r\n    };\r\n    \r\n    return () => eventSource.close();\r\n  }, [transferId]);\r\n  \r\n  return { \r\n    progress, \r\n    percentage: progress.total > 0 ? (progress.current / progress.total) * 100 : 0,\r\n    error \r\n  };\r\n}\r\n```\r\n\r\n### Performance Optimizations\r\n- Lazy loading for large playlists\r\n- Debounced search for real-time track matching\r\n- Caching strategies for frequently accessed data\r\n- Optimized database queries with proper indexing\r\n- CDN delivery for static assets and API responses\r\n\r\n### Security Features\r\n- JWT token-based authentication\r\n- Secure API key management\r\n- Input validation and sanitization\r\n- CORS configuration for cross-origin requests\r\n- Rate limiting to prevent API abuse","src/content/projects/songshuttle.mdx","b9e5abe8c260ac0c","songshuttle.mdx","smajobb",{"id":25,"data":27,"body":28,"filePath":29,"digest":30,"legacyId":31,"deferredRender":17},{},"# Småjobb\r\n\r\n## Overview\r\n\r\nSmåjobb is a local marketplace platform connecting youth with micro-jobs and freelance opportunities in their communities. The platform facilitates small-scale work arrangements, from gardening and tutoring to errands and odd jobs, creating economic opportunities for young people while providing convenient services for local residents.\r\n\r\n## Key Features\r\n\r\n### Job Posting and Discovery\r\n- **Geolocation-based job search** with radius filtering\r\n- **Category-based organization** (gardening, tutoring, errands, pet care, etc.)\r\n- **Advanced filtering** by price range, duration, and skill requirements\r\n- **Real-time job updates** with instant notifications\r\n\r\n### User Management\r\n- **Dual user profiles** for job seekers and employers\r\n- **Verification system** with identity and skill validation\r\n- **Portfolio showcase** for completed jobs and reviews\r\n- **Rating and review system** for trust and quality assurance\r\n\r\n### Communication System\r\n- **In-app messaging** between job seekers and employers\r\n- **Push notifications** for job matches and messages\r\n- **Automated matching** based on skills and location\r\n- **Dispute resolution** support for job-related issues\r\n\r\n### Payment and Security\r\n- **Secure payment processing** with escrow functionality\r\n- **Multi-step verification** for high-value jobs\r\n- **Insurance coverage** for certain job categories\r\n- **Background check integration** for safety assurance\r\n\r\nimport Mermaid from '@/components/Mermaid.astro';\r\n\r\n\u003CMermaid content={`flowchart TD\r\n    A[\"User Registration\"] --> B{\"User Type?\"}\r\n    B -->|Job Seeker| C[\"Complete Profile\"]\r\n    B -->|Employer| D[\"Verify Business\"]\r\n    C --> E[\"Browse Available Jobs\"]\r\n    D --> F[\"Post New Job\"]\r\n    E --> G[\"Apply for Job\"]\r\n    F --> H[\"Review Applications\"]\r\n    G --> I[\"Wait for Response\"]\r\n    H --> J[\"Select Applicant\"]\r\n    I --> K{\"Application Accepted?\"}\r\n    K -->|Yes| L[\"Start Job\"]\r\n    K -->|No| M[\"Continue Browsing\"]\r\n    J --> N[\"Job Assignment\"]\r\n    L --> O[\"Complete Work\"]\r\n    N --> O\r\n    O --> P[\"Submit for Review\"]\r\n    P --> Q[\"Payment Processing\"]\r\n    Q --> R[\"Rate & Review\"]\r\n    R --> S[\"Job Complete\"]`} />\r\n\r\n## Technical Highlights\r\n\r\n### Frontend Architecture\r\n- **React with TypeScript** for type-safe development\r\n- **Modern React patterns** including hooks, context, and custom components\r\n- **Responsive design** with mobile-first approach\r\n- **Progressive Web App** features for native-like experience\r\n\r\n### Backend Implementation\r\n- **C# ASP.NET Core** with clean architecture\r\n- **Entity Framework Core** for database operations\r\n- **JWT authentication** with role-based authorization\r\n- **SignalR** for real-time communication features\r\n\r\n### Cloud Infrastructure\r\n- **Google Cloud Run** for auto-scaling containerized services\r\n- **Cloud SQL (Postgres)** for relational data management\r\n- **Firebase Hosting** with custom domain support\r\n- **Cloud Storage** for file uploads and user documents\r\n\r\n### Real-time Features\r\n- **WebSocket connections** for live messaging\r\n- **Push notification service** for mobile alerts\r\n- **Real-time job updates** using SignalR hubs\r\n- **Live location tracking** for job proximity\r\n\r\n\u003CMermaid content={`sequenceDiagram\r\n    participant JobSeeker\r\n    participant Frontend\r\n    participant Backend\r\n    participant Database\r\n    participant PaymentAPI\r\n    participant NotificationService\r\n\r\n    JobSeeker->>Frontend: Browse Jobs\r\n    Frontend->>Backend: Get Jobs by Location\r\n    Backend->>Database: Query Jobs Table\r\n    Database-->>Backend: Job Listings\r\n    Backend-->>Frontend: Filtered Results\r\n    Frontend-->>JobSeeker: Display Jobs\r\n\r\n    JobSeeker->>Frontend: Apply for Job\r\n    Frontend->>Backend: Submit Application\r\n    Backend->>Database: Store Application\r\n    Backend->>NotificationService: Notify Employer\r\n    Backend-->>Frontend: Application Sent\r\n\r\n    Note over Backend,Database: Employer Reviews Application\r\n    Backend->>Database: Update Application Status\r\n    Backend->>NotificationService: Notify Job Seeker\r\n    Backend-->>Frontend: Status Update\r\n\r\n    JobSeeker->>Frontend: Complete Job\r\n    Frontend->>Backend: Mark Job Complete\r\n    Backend->>PaymentAPI: Process Payment\r\n    PaymentAPI-->>Backend: Payment Confirmed\r\n    Backend->>Database: Update Job Status\r\n    Backend->>NotificationService: Notify Both Parties\r\n    Backend-->>Frontend: Job Completed`} />\r\n\r\n### Database Design\r\n- **Normalized schema** with proper relationships\r\n- **Geospatial indexing** for location-based queries\r\n- **Full-text search** capabilities for job descriptions\r\n- **Audit trails** for all user actions and transactions\r\n\r\n### Security Implementation\r\n- **Multi-factor authentication** for sensitive operations\r\n- **Data encryption** at rest and in transit\r\n- **GDPR compliance** with data protection measures\r\n- **Regular security audits** and penetration testing\r\n\r\n### Performance Optimizations\r\n- **Database query optimization** with proper indexing\r\n- **Caching strategies** for frequently accessed data\r\n- **Image optimization** and CDN delivery\r\n- **Lazy loading** for large job listings\r\n- **Pagination** for efficient data loading\r\n\r\n## Code Highlights\r\n\r\n### Geospatial Queries with PostGIS\r\n```csharp\r\n// Efficient location-based job search with spatial indexing and distance calculation\r\npublic async Task\u003CList\u003CJob>> FindNearbyJobs(double lat, double lon, int radiusKm)\r\n{\r\n    var userLocation = new Point(lon, lat) { SRID = 4326 };\r\n    var radiusMeters = radiusKm * 1000;\r\n    \r\n    return await _context.Jobs\r\n        .Where(j => j.Status == JobStatus.Open)\r\n        .Where(j => j.Location.Distance(userLocation) \u003C= radiusMeters)\r\n        .OrderBy(j => j.Location.Distance(userLocation))\r\n        .Take(50)\r\n        .Select(j => new Job {\r\n            Id = j.Id,\r\n            Title = j.Title,\r\n            Description = j.Description,\r\n            Price = j.Price,\r\n            Distance = j.Location.Distance(userLocation) / 1000, // Convert to km\r\n            CreatedAt = j.CreatedAt\r\n        })\r\n        .ToListAsync();\r\n}\r\n```\r\n\r\n### SignalR Real-time Notifications\r\n```csharp\r\n// Real-time job application notifications with user groups and typing indicators\r\npublic class JobHub : Hub\r\n{\r\n    public async Task JoinJobGroup(string jobId)\r\n    {\r\n        await Groups.AddToGroupAsync(Context.ConnectionId, $\"job-{jobId}\");\r\n    }\r\n    \r\n    public async Task NotifyEmployer(string employerId, JobApplication application)\r\n    {\r\n        await Clients.User(employerId).SendAsync(\"NewApplication\", new {\r\n            JobId = application.JobId,\r\n            ApplicantName = application.Applicant.Name,\r\n            ApplicantRating = application.Applicant.AverageRating,\r\n            Timestamp = DateTime.UtcNow,\r\n            Message = application.CoverMessage\r\n        });\r\n    }\r\n    \r\n    public async Task NotifyTyping(string jobId, string userId, bool isTyping)\r\n    {\r\n        await Clients.GroupExcept($\"job-{jobId}\", Context.ConnectionId)\r\n            .SendAsync(\"UserTyping\", new { UserId = userId, IsTyping = isTyping });\r\n    }\r\n}\r\n```\r\n\r\n### TypeScript Type-safe API Client\r\n```typescript\r\n// Type-safe API client with automatic serialization and error handling\r\nclass SmajobApi {\r\n  private baseUrl: string;\r\n  \r\n  constructor(baseUrl: string = '/api') {\r\n    this.baseUrl = baseUrl;\r\n  }\r\n  \r\n  async applyForJob(jobId: string, application: JobApplicationDto): Promise\u003CApplication> {\r\n    const response = await this.request(`/jobs/${jobId}/apply`, {\r\n      method: 'POST',\r\n      body: JSON.stringify(application)\r\n    });\r\n    \r\n    return response.json();\r\n  }\r\n  \r\n  async getNearbyJobs(location: GeoLocation, radius: number): Promise\u003CJob[]> {\r\n    const params = new URLSearchParams({\r\n      lat: location.latitude.toString(),\r\n      lon: location.longitude.toString(),\r\n      radius: radius.toString()\r\n    });\r\n    \r\n    const response = await this.request(`/jobs/nearby?${params}`);\r\n    return response.json();\r\n  }\r\n  \r\n  private async request(endpoint: string, options: RequestInit = {}): Promise\u003CResponse> {\r\n    const url = `${this.baseUrl}${endpoint}`;\r\n    const config: RequestInit = {\r\n      headers: {\r\n        'Content-Type': 'application/json',\r\n        ...options.headers\r\n      },\r\n      ...options\r\n    };\r\n    \r\n    const response = await fetch(url, config);\r\n    \r\n    if (!response.ok) {\r\n      const error = await response.json().catch(() => ({ message: 'Unknown error' }));\r\n      throw new ApiError(response.status, error.message);\r\n    }\r\n    \r\n    return response;\r\n  }\r\n}\r\n\r\nclass ApiError extends Error {\r\n  constructor(public status: number, message: string) {\r\n    super(message);\r\n    this.name = 'ApiError';\r\n  }\r\n}\r\n```\r\n\r\n### Integration Features\r\n- **Third-party payment processors** (Stripe, PayPal)\r\n- **Background check services** for user verification\r\n- **Mapping services** for location features\r\n- **Email and SMS services** for notifications\r\n- **Analytics tracking** for user behavior insights","src/content/projects/smajobb.mdx","f95f7f2bf15b148e","smajobb.mdx","data/projects",{"id":32,"data":34,"filePath":67,"digest":68,"legacyId":69},[35,54],{"slug":18,"name":36,"tagline":37,"status":38,"stack":39,"url":46,"repo":47,"thumbnail":48,"tags":49},"SongShuttle","Music transfer app: move playlists from YouTube to Spotify","Live",[40,41,42,43,44,45],"React","Tailwind","C#","Cloud Run","Cloud SQL (Postgres)","Firebase Hosting","https://songshuttle-b7b57.web.app/","","/og/songshuttle.png",[50,51,52,53],"music","transfer","spotify","youtube",{"slug":25,"name":55,"tagline":56,"status":57,"stack":58,"url":60,"repo":47,"thumbnail":61,"tags":62},"Småjobb","Youth micro‑jobs platform for local communities","Beta",[40,59,42,43,44,45],"TypeScript","https://ultra-tendril-474220-u7.web.app/","/og/ultra-tendril.png",[63,64,65,66],"marketplace","community","youth","freelance","src/content/projects/data/projects.json","d6fecf3c72ec11e5","data/projects.json"]